<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Microfluidic Flow Annotator - Beta</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif; }
    #app { height: 100%; display: flex; flex-direction: column; gap: 0; background: linear-gradient(180deg,#071126,#041026); color: #cfe8ff; }
    
    .header { padding: 16px 20px; background: linear-gradient(135deg, #0a1929 0%, #1a2332 100%); border-bottom: 2px solid rgba(54,163,255,0.3); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .header-content { display: flex; align-items: center; gap: 16px; }
    .logo-section { display: flex; align-items: center; gap: 12px; }
    .app-title { font-size: 28px; font-weight: 700; margin: 0; background: linear-gradient(135deg, #36a3ff 0%, #2fb8ff 50%, #4caf50 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .beta-badge { background: linear-gradient(135deg, #ff6b6b, #ee5a6f); color: white; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; box-shadow: 0 2px 8px rgba(255,107,107,0.4); }
    .subtitle { color: #9aa4b2; font-size: 14px; margin: 4px 0 0 0; }
    
    .main-content { display: flex; gap: 16px; padding: 12px; flex: 1; min-height: 0; }
    
    .sidebar { width: 360px; background: rgba(255,255,255,0.04); border-radius: 10px; padding: 12px; display: flex; flex-direction: column; }
    .topbar { display: flex; align-items: center; gap: 8px; }
    .topbar h3 { margin: 0; flex: 1; }
    .btn { background: linear-gradient(180deg,#36a3ff,#1d80c9); border: none; color: white; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: 600; transition: all 0.2s; }
    .btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(54,163,255,0.4); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .hint { font-size: 13px; color: #9aa4b2; margin: 8px 0; line-height: 1.4; }
    .imageList { list-style: none; padding: 0; margin: 8px 0; display: flex; flex-direction: column; gap: 8px; overflow: auto; flex: 1; }
    .imageList li { display: flex; gap: 8px; align-items: center; padding: 8px; border-radius: 8px; cursor: pointer; border: 1px solid transparent; transition: all 0.2s; }
    .imageList li:hover { background: rgba(255, 255, 255, 0.05); }
    .imageList li.active { background: rgba(54, 163, 255, 0.15); border-color: rgba(54,163,255,0.3); }
    .thumb { width: 64px; height: 48px; object-fit: cover; border-radius: 6px; background: #0b1a33; }
    .meta { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
    .name { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .sub { font-size: 12px; color: #9aa4b2; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .viewer { flex: 1; display: flex; flex-direction: column; min-width: 0; }
    .viewerTop { display: flex; align-items: center; gap: 8px; }
    .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .content { display: flex; flex-direction: column; gap: 12px; margin-top: 12px; }
    .left { min-width: 0; display: flex; flex-direction: column; gap: 8px; }
    .image-wrap { position: relative; background: rgba(255,255,255,0.04); border-radius: 10px; padding: 8px; border: 1px solid rgba(255,255,255,0.05); }
    .image-wrap img { display: block; max-width: 100%; border-radius: 8px; }
    .image-wrap canvas.overlay { position: absolute; left: 8px; top: 8px; border-radius: 8px; pointer-events: auto; cursor: crosshair; }
  /* Doodle canvas sits above the main overlay and is ephemeral (not persisted) */
  .image-wrap canvas.doodle-canvas { position: absolute; left: 8px; top: 8px; border-radius: 8px; pointer-events: auto; cursor: crosshair; z-index: 20; }
    /* added visual crosshair indicator for better click precision */
    .crosshair-indicator { 
      position: absolute; 
      pointer-events: none; 
      display: none; 
      width: 20px; 
      height: 20px; 
      margin: -10px 0 0 -10px;
      z-index: 10; 
    }
    .crosshair-indicator::before, .crosshair-indicator::after { 
      content: ''; 
      position: absolute; 
      background: rgba(54, 163, 255, 0.9); 
      box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }
    .crosshair-indicator::before { 
      width: 1px; 
      height: 20px; 
      left: 50%; 
      top: 0; 
      transform: translateX(-50%); 
    }
    .crosshair-indicator::after { 
      width: 20px; 
      height: 1px; 
      left: 0; 
      top: 50%; 
      transform: translateY(-50%); 
    }
    .crosshair-indicator.active { display: block; }
    .note { font-size: 13px; color: #9aa4b2; line-height: 1.4; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; }

    .right { width: 100%; }
    .table-card { background: rgba(255,255,255,0.04); border-radius: 10px; padding: 12px; border: 1px solid rgba(255,255,255,0.05); overflow-x: auto; max-height: 500px; overflow-y: auto; }
    .table-wrapper { overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; min-width: 600px; }
    thead th { text-align: left; padding: 6px 4px; color: #9aa4b2; background: rgba(255,255,255,0.06); white-space: nowrap; position: sticky; top: 0; z-index: 1; }
    td,th { padding: 6px 4px; border-bottom: 1px solid rgba(255,255,255,0.06); }
    tbody tr { transition: background-color 0.2s, transform 0.1s; cursor: pointer; }
    tbody tr:hover { background: rgba(54,163,255,0.15); }
    tbody tr.highlight { background: rgba(255,235,59,0.25) !important; transform: scale(1.02); box-shadow: 0 0 8px rgba(255,235,59,0.4); }
    
    .btn-delete { background: transparent; border: none; color: #ff6b6b; cursor: pointer; padding: 4px 8px; border-radius: 4px; font-size: 16px; transition: all 0.2s; }
    .btn-delete:hover { background: rgba(255,107,107,0.2); transform: scale(1.1); }
    .btn-delete:active { transform: scale(0.95); }

    @media (min-width: 1100px) {
      .content { flex-direction: row; }
      .left { flex: 1; }
      .right { width: 460px; }
    }

    .modal { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.10); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .modal .panel { width: min(720px, 92vw); max-height: 85vh; overflow-y: auto; background: #0e1e3a; color: #cfe8ff; border: 1px solid rgba(255,255,255,0.6); border-radius: 12px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); position: relative; }
    .modal .panel h3 { margin-top: 0; color: #36a3ff; }
    .modal .panel h4 { color: #4caf50; margin-top: 16px; }
    .modal .panel ul { line-height: 1.8; }
    .modal .panel code { background: rgba(54,163,255,0.2); padding: 2px 6px; border-radius: 4px; color: #2fb8ff; }
    
    .modal-buttons-fixed { position: fixed; bottom: 20px; right: 20px; z-index: 1001; }
    
    .confirm-modal { background: rgba(0,0,0,0.3) !important; backdrop-filter: blur(4px); }
    .confirm-modal .panel { background: rgba(14,30,58,0.85) !important; backdrop-filter: blur(10px); }
    
    .btn-trajectory { background: linear-gradient(180deg,#9c27b0,#7b1fa2); }
    .btn-trajectory:hover:not(:disabled) { box-shadow: 0 4px 12px rgba(156,39,176,0.4); }
    .btn-trajectory.active { background: linear-gradient(180deg,#4caf50,#388e3c); box-shadow: 0 0 12px rgba(76,175,80,0.6); }
    
    @keyframes pulse-glow {
      0%, 100% { 
        background: rgba(156,39,176,0.3);
        border-color: rgba(156,39,176,0.6);
        box-shadow: 0 0 0 0 rgba(156,39,176,0.7);
      }
      50% { 
        background: rgba(156,39,176,0.5);
        border-color: rgba(156,39,176,0.9);
        box-shadow: 0 0 20px 5px rgba(156,39,176,0.6);
      }
    }
    
    .trajectory-mode-hint { 
      background: rgba(156,39,176,0.2); 
      border: 1px solid rgba(156,39,176,0.4); 
      padding: 8px; 
      border-radius: 6px; 
      font-size: 13px; 
      margin-top: 8px; 
    }
    
    .trajectory-mode-hint.drawing { 
      animation: pulse-glow 2s ease-in-out infinite;
      font-weight: 600;
    }
    
    .version-badge {
      position: fixed;
      bottom: 12px;
      right: 12px;
      background: rgba(0,0,0,0.5);
      color: #9aa4b2;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-family: 'Monaco', 'Courier New', monospace;
      border: 1px solid rgba(255,255,255,0.1);
      z-index: 100;
      backdrop-filter: blur(8px);
    }
    
    .confirm-modal-content {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .confirm-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    
    .btn-confirm {
      background: linear-gradient(180deg,#4caf50,#388e3c);
      padding: 10px 20px;
    }
    
    .btn-confirm:hover {
      box-shadow: 0 4px 12px rgba(76,175,80,0.4);
    }
    
    .btn-cancel {
      background: linear-gradient(180deg,#ff6b6b,#ee5a6f);
      padding: 10px 20px;
    }
    
    .btn-cancel:hover {
      box-shadow: 0 4px 12px rgba(255,107,107,0.4);
    }
    
    .hint-box {
      background: rgba(54,163,255,0.1);
      border-left: 3px solid #36a3ff;
      padding: 10px;
      border-radius: 4px;
      font-size: 13px;
      color: #cfe8ff;
    }
    
    .measurement-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
      color: white;
      padding: 30px 40px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(255,152,0,0.6), 0 0 0 3px rgba(255,152,0,0.3);
      z-index: 2001;
      display: none;
      text-align: center;
      min-width: 300px;
      animation: popIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      cursor: pointer;
    }
    
    .measurement-popup-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      display: none;
      backdrop-filter: blur(2px);
    }
    
    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    
    .measurement-popup h3 {
      margin: 0 0 16px 0;
      font-size: 24px;
      color: white;
    }
    
    .measurement-popup .value {
      font-size: 48px;
      font-weight: 700;
      margin: 16px 0;
      text-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .measurement-popup .unit {
      font-size: 24px;
      opacity: 0.9;
    }
    
    .measurement-popup .info {
      font-size: 14px;
      opacity: 0.8;
      margin-top: 12px;
    }
  </style>
  <!-- Libraries from CDN (required): JSZip for ZIP parsing, UTIF for TIFF decoding -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/utif@3.0.0/UTIF.min.js"></script>
</head>
<body>
  <div id="app">
    <header class="header">
      <div class="header-content">
        <div class="logo-section">
          <h1 class="app-title">Microfluidic Flow Annotator</h1>
          <span class="beta-badge">Beta</span>
        </div>
      </div>
      <p class="subtitle">Dedicated for ENGSCI 2T8</p>
    </header>
    
    <div class="main-content">
    <aside class="sidebar">
      <div class="topbar">
        <h3>Images</h3>
        <button class="btn" id="btnHelp">Instructions</button>
      </div>
      <div class="hint">Upload a .zip containing folders like data/images and data/metadata (XML with Exposure). TIFFs are supported via UTIF.</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <input type="file" id="zipInput" accept="application/zip" />
        <button class="btn" id="btnUseZip" disabled>Use ZIP</button>
      </div>
      <ul class="imageList" id="imageList"></ul>
      <div class="hint">
        Scale: <input type="number" id="inpScalePx" value="156" style="width:80px"> px per
        <input type="number" id="inpScaleUm" value="100" style="width:80px"> ¬µm
      </div>
      <div class="hint">
        Time Error: ¬±<input type="number" id="inpTimeError" value="0.5" step="0.1" style="width:60px"> ms
      </div>
    </aside>

    <main class="viewer">
      <div class="viewerTop">
        <h3 id="title">No image selected</h3>
        <div style="flex:1"></div>
        <div class="controls">
          <button class="btn btn-trajectory" id="btnTrajectory" disabled>Enable Trajectory Analysis</button>
          <button class="btn" id="btnMeasure" disabled style="background: linear-gradient(180deg,#ff9800,#f57c00);">üìè Measure Length</button>
          <button class="btn" id="btnDoodle" disabled>‚úèÔ∏è Doodle</button>
          <button class="btn" id="btnClearBoundaries" disabled style="display:none;">Clear Boundaries</button>
          <button class="btn" id="btnUndo" disabled>‚Ü∂ Undo</button>
          <button class="btn" id="btnClear" disabled>Clear All</button>
          <input type="file" id="csvInput" accept="text/csv" />
          <button class="btn" id="btnSaveCsv" disabled>Save CSV</button>
          <span id="dirtyBadge" style="font-size:12px;color:#ffeb3b;display:none;">Unsaved</span>
        </div>
      </div>
      <div class="content">
        <div class="left">
          <div class="image-wrap" id="imageWrap">
            <img id="img" alt="" />
            <canvas id="overlay" class="overlay"></canvas>
            <!-- Ephemeral doodle canvas: user can sketch flow paths; cleared when exiting doodle mode -->
            <canvas id="doodleCanvas" class="doodle-canvas" style="display:none;"></canvas>
            <div id="crosshair" class="crosshair-indicator"></div>
            <canvas id="magnifier" style="display:none; position:absolute; border:3px solid #36a3ff; border-radius:50%; pointer-events:none; z-index:15; box-shadow: 0 0 20px rgba(54,163,255,0.8);"></canvas>
          </div>
          <div class="note">
            <b>Click</b>: start or finish a line. <b>Hold 'A' + click</b>: add intermediate points for curved paths. <b>Press 'U'</b>: toggle magnifier.
            <span id="wipStatus"></span>
            <span id="measureStatus" style="color:#ff9800;display:none;"></span>
            <br>Exposure from metadata: <span id="expLabel">N/A</span> ms
            <div id="trajectoryModeHint" class="trajectory-mode-hint" style="display:none;">
              <b>Trajectory Analysis Mode:</b><br>
              <span id="trajectoryStep">Step 1: Draw the TOP boundary of the tube (click multiple points, finish at end)</span>
            </div>
          </div>
        </div>
        
        <div class="right">
          <div class="table-card">
            <h4>Annotations</h4>
            <div class="table-wrapper">
              <table>
                <thead>
                  <tr>
                    <th>Actions</th>
                    <th>#</th>
                    <th>Pts</th>
                    <th>Start (px)</th>
                    <th>End (px)</th>
                    <th>Dist (¬µm)</th>
                    <th>¬±Err</th>
                    <th>Exp (ms)</th>
                    <th>¬±Err</th>
                    <th>Vel (¬µm/s)</th>
                    <th>¬±Err</th>
                    <th id="thDistFromCenter" style="display:none;">Center Dist (¬µm)</th>
                  </tr>
                </thead>
                <tbody id="tableBody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </main>
    </div>
    
    <div class="version-badge">v1.4.3 Olympia</div>
  </div>

  <div class="measurement-popup-backdrop" id="measurementBackdrop"></div>
  <div class="measurement-popup" id="measurementPopup">
    <h3>üìè Measurement Result</h3>
    <div class="value" id="measurementValue">0.000</div>
    <div class="unit">¬µm</div>
    <div class="info">Click anywhere to continue</div>
  </div>

  <div class="modal" id="helpModal">
    <div class="panel">
      <h3>üìñ How to Use the Microfluidic Flow Annotator</h3>
      
      <h4>üìÅ 1. Load Your Data</h4>
      <ul>
        <li>Prepare a <b>.zip</b> file with your images and metadata:
          <pre style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 6px; overflow-x: auto;">data/
  images/   # .tif/.tiff/.png/.jpg
  metadata/ # XML files with Exposure info
            # Format: xxxx.tif.cal.xml</pre>
        </li>
        <li>Click <b>"Use ZIP"</b> to load. The app will index images and match metadata automatically.</li>
      </ul>
      
      <h4>‚úèÔ∏è 2. Annotate Particle Trajectories</h4>
      <ul>
        <li><b>Click</b> on the image to start a trajectory line</li>
        <li><b>Hold 'A' + click</b> to add intermediate points for curved particle paths</li>
        <li><b>Click again</b> to finish the trajectory</li>
        <li>The tool automatically calculates:
          <ul>
            <li>Distance traveled (in ¬µm) with propagated error</li>
            <li>Velocity (¬µm/s) with propagated error based on exposure time</li>
            <li>Error propagation: Distance error = ¬±0.25 pixels (converted to ¬µm)</li>
            <li>Time error: adjustable in sidebar (default ¬±0.5 ms)</li>
            <li>Velocity error: ‚àö[(dist_err/dist)¬≤ + (time_err/time)¬≤] √ó velocity</li>
          </ul>
        </li>
      </ul>
      
      <h4>üìè 2.5. Length Measurement Tool</h4>
      <ul>
        <li>Click <b>"üìè Measure Length"</b> to activate measurement mode</li>
        <li>Draw lines just like annotations (click to add points, hold 'A' for curves)</li>
        <li>Length is displayed in real-time but <b>not saved</b> to annotations</li>
        <li>Useful for quick measurements or calibration checks</li>
        <li>Click the button again to exit measurement mode</li>
      </ul>
      
      <h4>üéØ 3. Trajectory Analysis Mode (Optional)</h4>
      <p>Enable advanced positioning analysis to measure particle distances from tube centerline:</p>
      <ul>
        <li>Click <b>"Enable Trajectory Analysis"</b> button</li>
        <li><b>Step 1:</b> Draw the <span style="color: #ff6b6b;">TOP boundary</span> of your tube
          <ul>
            <li>Click multiple points along the top edge</li>
            <li>Hold 'A' to add points for curved sections</li>
            <li>Click to finish the boundary line</li>
          </ul>
        </li>
        <li><b>Step 2:</b> Draw the <span style="color: #ff6b6b;">BOTTOM boundary</span> of your tube
          <ul>
            <li>Same process as top boundary</li>
            <li>Boundaries can have different lengths</li>
          </ul>
        </li>
        <li>The tool will compute a <span style="color: #4caf50;">green centerline</span> automatically</li>
        <li>All trajectories now show <code>Dist from Center (¬µm)</code> data</li>
        <li>Use <b>"Clear Boundaries"</b> to redraw or adjust boundaries</li>
      </ul>
      
      <h4>üíæ 4. Save & Export</h4>
      <ul>
        <li><b>Auto-save:</b> Annotations save automatically to browser localStorage</li>
        <li><b>CSV Export:</b> Click "Save CSV" to download analysis data
          <ul>
            <li>Includes all trajectory data</li>
            <li>Distance from center (if trajectory analysis enabled)</li>
            <li>Compatible with Excel, Python, R, and other analysis tools</li>
          </ul>
        </li>
        <li><b>CSV Import:</b> Load previously saved annotations back into the tool</li>
      </ul>
      
      <h4>üî¨ Data Compatibility</h4>
      <p>The exported data is ready for downstream analysis:</p>
      <ul>
        <li>Statistical analysis (mean velocity, position distribution)</li>
        <li>Flow profile characterization</li>
        <li>Velocity vs. position correlation studies</li>
        <li>Machine learning feature extraction</li>
        <li>Laminar flow validation</li>
      </ul>
      
      <h4>ÔøΩ 5. Magnifier Tool</h4>
      <ul>
        <li>Press <b>'U'</b> key to toggle magnifier on/off</li>
        <li>When enabled, a 3√ó magnified view follows your cursor</li>
        <li>Helps with precise point placement on particle trajectories</li>
        <li>Magnifier shows a crosshair at the exact click location</li>
      </ul>
      
      <h4>ÔøΩüí° Tips</h4>
      <ul>
        <li>Complex tube shapes are supported - just trace the actual boundaries</li>
        <li>Each image maintains independent tube boundaries</li>
        <li>Unsaved changes trigger a warning before closing</li>
        <li>Use the undo button (‚Ü∂) to remove the last annotation</li>
        <li>Scale settings (px per ¬µm) apply to all calculations</li>
        <li>Adjust time error in sidebar to reflect your experimental uncertainty</li>
        <li>Use measurement tool for quick checks without cluttering annotation data</li>
      </ul>
      
      <div class="modal-buttons-fixed">
        <button class="btn" id="btnCloseHelp">Got it!</button>
      </div>
    </div>
  </div>

  <div class="modal confirm-modal" id="confirmBoundaryModal" style="display:none;">
    <div class="panel">
      <h3 id="confirmBoundaryTitle">Confirm Boundary Line</h3>
      <div class="confirm-modal-content">
        <p id="confirmBoundaryMessage">Is this the boundary line you want to use?</p>
        <div class="hint-box">
          üí° <b>Hint:</b> You can hold down 'A' and click to add multiple points for curved boundaries
        </div>
        <div class="confirm-modal-buttons">
          <button class="btn btn-cancel" id="btnCancelBoundary">No, Redo</button>
          <button class="btn btn-confirm" id="btnConfirmBoundary">Yes, Confirm</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  ;(() => {
    const $ = (id) => document.getElementById(id)

    // ---------- State ----------
    let zipFile = null
    let datasetId = 'session'
    let images = []
    let selected = null
    let annotations = []
    let history = []
    let currentPoints = []
    let dirty = false
    let holdingA = false
    
    // Trajectory analysis state
    let trajectoryMode = false
    let trajectoryStep = 0
    let topBoundary = null
    let bottomBoundary = null
    let tubeCenterline = null
    
    // Measurement mode state
    let measureMode = false
    let measurePoints = []
    
    // Magnifier state
    let magnifierEnabled = false
    
    // Hover state
    let hoveredAnnotationIndex = -1

    // ---------- Elements ----------
    const imgEl = $('img')
    const canvas = $('overlay')
    const ctx = canvas.getContext('2d')
    const crosshair = $('crosshair')
    const magnifierCanvas = $('magnifier')
    const magnifierCtx = magnifierCanvas.getContext('2d')
    const imageWrap = $('imageWrap')
    const imageListEl = $('imageList')
    const titleEl = $('title')
    const expLabel = $('expLabel')
    const wipStatus = $('wipStatus')
    const measureStatus = $('measureStatus')
    const tableBody = $('tableBody')
    const dirtyBadge = $('dirtyBadge')
    const thDistFromCenter = $('thDistFromCenter')
    const trajectoryModeHint = $('trajectoryModeHint')
    const trajectoryStepEl = $('trajectoryStep')

    const btnHelp = $('btnHelp')
  const btnDoodle = $('btnDoodle')
    const helpModal = $('helpModal')
    const btnCloseHelp = $('btnCloseHelp')
    const confirmBoundaryModal = $('confirmBoundaryModal')
    const confirmBoundaryTitle = $('confirmBoundaryTitle')
    const confirmBoundaryMessage = $('confirmBoundaryMessage')
    const btnConfirmBoundary = $('btnConfirmBoundary')
    const btnCancelBoundary = $('btnCancelBoundary')
    const zipInput = $('zipInput')
    const btnUseZip = $('btnUseZip')
    const btnTrajectory = $('btnTrajectory')
    const btnMeasure = $('btnMeasure')
    const btnClearBoundaries = $('btnClearBoundaries')
    const btnUndo = $('btnUndo')
    const btnClear = $('btnClear')
    const csvInput = $('csvInput')
    const btnSaveCsv = $('btnSaveCsv')
    const inpScalePx = $('inpScalePx')
    const inpScaleUm = $('inpScaleUm')
    const inpTimeError = $('inpTimeError')
    const measurementPopup = $('measurementPopup')
    const measurementBackdrop = $('measurementBackdrop')
    const measurementValue = $('measurementValue')
  const doodleCanvas = $('doodleCanvas')
  const doodleCtx = doodleCanvas.getContext('2d')
    
    // Pending boundary for confirmation
    let pendingBoundary = null
    let pendingBoundaryStep = 0

    // ---------- Utilities ----------
    const pad = 8
    const dpr = () => window.devicePixelRatio || 1
    const pxToMicron = (px) => px * (Number(inpScaleUm.value) / Number(inpScalePx.value || 1))
    const storageKey = (imgName) => `standalone::${datasetId}::${imgName}`
    const storageKeyTrajectory = (imgName) => `standalone::${datasetId}::${imgName}::trajectory`

    function canvasToImage(canvasX, canvasY) {
      if (!imgEl.naturalWidth || !imgEl.naturalHeight) return { x: 0, y: 0 }
      
      const imgDisplayWidth = imgEl.clientWidth
      const imgDisplayHeight = imgEl.clientHeight
      
      const scaleX = imgEl.naturalWidth / imgDisplayWidth
      const scaleY = imgEl.naturalHeight / imgDisplayHeight
      
      const imageX = canvasX * scaleX
      const imageY = canvasY * scaleY
      
      return { x: imageX, y: imageY }
    }
    
    function imageToCanvas(imageX, imageY) {
      if (!imgEl.naturalWidth || !imgEl.naturalHeight) return { x: 0, y: 0 }
      
      const imgDisplayWidth = imgEl.clientWidth
      const imgDisplayHeight = imgEl.clientHeight
      
      const scaleX = imgDisplayWidth / imgEl.naturalWidth
      const scaleY = imgDisplayHeight / imgEl.naturalHeight
      
      const canvasX = imageX * scaleX
      const canvasY = imageY * scaleY
      
      return { x: canvasX, y: canvasY }
    }

    function setDirty(v) {
      dirty = v
      dirtyBadge.style.display = dirty ? 'inline-block' : 'none'
    }

  // Doodle helpers (support multiple strokes)
  let doodleMode = false
  let doodleStrokes = [] // array of strokes; each stroke is array of points

    function resizeDoodleCanvas() {
      if (!imgEl.naturalWidth) return
      const DPR = dpr()
      const displayW = imgEl.clientWidth
      const displayH = imgEl.clientHeight
      doodleCanvas.width = Math.max(1, Math.floor((displayW - pad*2) * DPR))
      doodleCanvas.height = Math.max(1, Math.floor((displayH - pad*2) * DPR))
      doodleCanvas.style.width = `${displayW - pad*2}px`
      doodleCanvas.style.height = `${displayH - pad*2}px`
      doodleCanvas.style.left = pad + 'px'
      doodleCanvas.style.top = pad + 'px'
      doodleCtx.setTransform(DPR,0,0,DPR,0,0)
    }

    // ---------- Trajectory Analysis Functions ----------
    
    function computeCenterline(topPts, bottomPts) {
      if (!topPts || !bottomPts || topPts.length < 2 || bottomPts.length < 2) return null
      
      const refPts = topPts.length >= bottomPts.length ? topPts : bottomPts
      const otherPts = topPts.length >= bottomPts.length ? bottomPts : topPts
      
      const getArcLengths = (pts) => {
        const lengths = [0]
        for (let i = 1; i < pts.length; i++) {
          const dx = pts[i].x - pts[i-1].x
          const dy = pts[i].y - pts[i-1].y
          lengths.push(lengths[i-1] + Math.hypot(dx, dy))
        }
        return lengths
      }
      
      const refLengths = getArcLengths(refPts)
      const otherLengths = getArcLengths(otherPts)
      const refTotalLength = refLengths[refLengths.length - 1]
      const otherTotalLength = otherLengths[otherLengths.length - 1]
      
      const interpolatePoint = (pts, lengths, totalLength, t) => {
        const targetLength = t * totalLength
        for (let i = 0; i < lengths.length - 1; i++) {
          if (targetLength >= lengths[i] && targetLength <= lengths[i + 1]) {
            const segmentLength = lengths[i + 1] - lengths[i]
            const localT = segmentLength > 0 ? (targetLength - lengths[i]) / segmentLength : 0
            return {
              x: pts[i].x + localT * (pts[i + 1].x - pts[i].x),
              y: pts[i].y + localT * (pts[i + 1].y - pts[i].y)
            }
          }
        }
        return pts[pts.length - 1]
      }
      
      const numSamples = Math.max(refPts.length, otherPts.length, 50)
      const centerline = []
      for (let i = 0; i < numSamples; i++) {
        const t = i / (numSamples - 1)
        const refPt = interpolatePoint(refPts, refLengths, refTotalLength, t)
        const otherPt = interpolatePoint(otherPts, otherLengths, otherTotalLength, t)
        centerline.push({
          x: (refPt.x + otherPt.x) / 2,
          y: (refPt.y + otherPt.y) / 2
        })
      }
      
      return centerline
    }
    
    // Find closest point on centerline and compute signed distance
    // Returns negative for left side, positive for right side
    function distanceFromCenterline(point, centerline) {
      if (!centerline || centerline.length === 0) return null
      
      let minDist = Infinity
      let closestSegmentIdx = -1
      let closestPointOnSegment = null
      
      // Find closest point on centerline segments
      for (let i = 0; i < centerline.length - 1; i++) {
        const p1 = centerline[i]
        const p2 = centerline[i + 1]
        
        // Calculate closest point on line segment
        const dx = p2.x - p1.x
        const dy = p2.y - p1.y
        const len2 = dx * dx + dy * dy
        
        let closestPt
        if (len2 === 0) {
          closestPt = p1
        } else {
          let t = ((point.x - p1.x) * dx + (point.y - p1.y) * dy) / len2
          t = Math.max(0, Math.min(1, t))
          closestPt = {
            x: p1.x + t * dx,
            y: p1.y + t * dy
          }
        }
        
        const dist = Math.hypot(point.x - closestPt.x, point.y - closestPt.y)
        if (dist < minDist) {
          minDist = dist
          closestSegmentIdx = i
          closestPointOnSegment = closestPt
        }
      }
      
      if (closestSegmentIdx === -1) return 0
      
      // Determine sign using cross product
      // Vector from closest point to particle
      const toPoint = {
        x: point.x - closestPointOnSegment.x,
        y: point.y - closestPointOnSegment.y
      }
      
      // Direction vector of centerline segment
      const p1 = centerline[closestSegmentIdx]
      const p2 = centerline[closestSegmentIdx + 1]
      const direction = {
        x: p2.x - p1.x,
        y: p2.y - p1.y
      }
      
      // Cross product to determine left/right
      // Positive cross product = right side, negative = left side
      const cross = direction.x * toPoint.y - direction.y * toPoint.x
      
      return cross >= 0 ? minDist : -minDist
    }
    
    function computeLineCentroid(points) {
      if (!points || points.length === 0) return null
      
      if (points.length === 1) return points[0]
      
      let totalLength = 0
      let weightedX = 0
      let weightedY = 0
      
      for (let i = 0; i < points.length - 1; i++) {
        const dx = points[i + 1].x - points[i].x
        const dy = points[i + 1].y - points[i].y
        const segmentLength = Math.hypot(dx, dy)
        const midX = (points[i].x + points[i + 1].x) / 2
        const midY = (points[i].y + points[i + 1].y) / 2
        
        weightedX += midX * segmentLength
        weightedY += midY * segmentLength
        totalLength += segmentLength
      }
      
      if (totalLength === 0) return points[0]
      
      return {
        x: weightedX / totalLength,
        y: weightedY / totalLength
      }
    }
    
    function recomputeTrajectoryDistances() {
      if (!tubeCenterline) return
      
      annotations.forEach(a => {
        const centroid = computeLineCentroid(a.points)
        if (centroid) {
          const distPx = distanceFromCenterline(centroid, tubeCenterline)
          a.distFromCenter = distPx !== null ? pxToMicron(distPx) : null
        }
      })
    }
    
    function persistTrajectory() {
      if (!selected) return
      try {
        const data = { topBoundary, bottomBoundary, tubeCenterline }
        localStorage.setItem(storageKeyTrajectory(selected.name), JSON.stringify(data))
      } catch {}
    }
    
    function loadTrajectoryFor(name) {
      try {
        const raw = localStorage.getItem(storageKeyTrajectory(name))
        if (raw) {
          const data = JSON.parse(raw)
          topBoundary = data.topBoundary
          bottomBoundary = data.bottomBoundary
          tubeCenterline = data.tubeCenterline
          
          if (tubeCenterline) {
            trajectoryMode = true
            trajectoryStep = 3
            updateTrajectoryButtonState()
            recomputeTrajectoryDistances()
          } else {
            resetTrajectoryState()
          }
        } else {
          resetTrajectoryState()
        }
      } catch {
        resetTrajectoryState()
      }
    }
    
    function resetTrajectoryState() {
      topBoundary = null
      bottomBoundary = null
      tubeCenterline = null
      trajectoryMode = false
      trajectoryStep = 0
      updateTrajectoryButtonState()
    }
    
    function updateTrajectoryButtonState() {
      if (trajectoryMode && trajectoryStep === 3) {
        btnTrajectory.textContent = 'Disable Trajectory Analysis'
        btnTrajectory.classList.add('active')
        btnClearBoundaries.style.display = 'inline-block'
        btnClearBoundaries.disabled = false
        trajectoryModeHint.style.display = 'block'
        trajectoryModeHint.classList.remove('drawing')
        trajectoryStepEl.textContent = 'Trajectory analysis active. Centerline computed.'
        thDistFromCenter.style.display = 'table-cell'
      } else if (trajectoryMode && trajectoryStep < 3) {
        btnTrajectory.textContent = 'Disable Trajectory Analysis'
        btnTrajectory.classList.add('active')
        btnClearBoundaries.style.display = 'inline-block'
        btnClearBoundaries.disabled = false
        trajectoryModeHint.style.display = 'block'
        trajectoryModeHint.classList.add('drawing')
        thDistFromCenter.style.display = 'none'
      } else {
        btnTrajectory.textContent = 'Enable Trajectory Analysis'
        btnTrajectory.classList.remove('active')
        btnClearBoundaries.style.display = 'none'
        btnClearBoundaries.disabled = true
        trajectoryModeHint.style.display = 'none'
        trajectoryModeHint.classList.remove('drawing')
        thDistFromCenter.style.display = 'none'
      }
    }

    function pushHistory() {
      history.push(JSON.parse(JSON.stringify(annotations)))
      btnUndo.disabled = history.length === 0
    }

    function loadAnnotationsFor(name) {
      try {
        const raw = localStorage.getItem(storageKey(name))
        annotations = raw ? JSON.parse(raw) : []
      } catch { annotations = [] }
      history = []
      btnUndo.disabled = true
      btnClear.disabled = annotations.length === 0
      btnSaveCsv.disabled = !selected
      setDirty(false)
      loadTrajectoryFor(name)
      renderTable()
      drawAll()
    }

    function persist() {
      if (!selected) return
      try { localStorage.setItem(storageKey(selected.name), JSON.stringify(annotations)) } catch {}
    }

    // ---------- Help modal ----------
    btnHelp.addEventListener('click', () => { helpModal.style.display = 'flex' })
    btnCloseHelp.addEventListener('click', () => { helpModal.style.display = 'none' })
    
    helpModal.addEventListener('click', (e) => {
      if (e.target === helpModal) helpModal.style.display = 'none'
    })

    // ---------- Doodle Mode (ephemeral) ----------
    // Toggle doodle mode via button; drawings are NOT persisted and cleared when exiting
    function clearDoodle() {
      doodleStrokes = []
      doodleCtx.clearRect(0,0,doodleCanvas.width, doodleCanvas.height)
      // restore undo button state to annotation history availability
      try { btnUndo.disabled = history.length === 0 } catch(e){}
    }

    function drawDoodle() {
      doodleCtx.clearRect(0,0,doodleCanvas.width, doodleCanvas.height)
      if (!doodleStrokes || doodleStrokes.length === 0) return
      doodleCtx.lineWidth = 2
      doodleCtx.strokeStyle = 'rgba(76,175,80,0.95)'
      doodleCtx.fillStyle = 'rgba(76,175,80,0.95)'
      doodleStrokes.forEach(stroke => {
        if (!stroke || stroke.length === 0) return
        doodleCtx.beginPath()
        stroke.forEach((p, i) => {
          const c = imageToCanvas(p.x, p.y)
          if (i===0) doodleCtx.moveTo(c.x, c.y)
          else doodleCtx.lineTo(c.x, c.y)
        })
        doodleCtx.stroke()
      })
    }

    // Doodle input handling (freehand with mouse)
    let doodleDrawing = false
    doodleCanvas.addEventListener('mousedown', (e) => {
      if (!doodleMode || !selected) return
      doodleDrawing = true
      const rect = doodleCanvas.getBoundingClientRect()
      const cx = e.clientX - rect.left
      const cy = e.clientY - rect.top
      const p = canvasToImage(cx, cy)
      // start a new stroke
      doodleStrokes.push([p])
      // enable undo for doodle strokes
      try { btnUndo.disabled = false } catch(e){}
      drawDoodle()
    })
  // Prevent clicks on doodle canvas from falling through to the annotation canvas
  doodleCanvas.addEventListener('click', (e) => { e.stopPropagation(); })
    window.addEventListener('mousemove', (e) => {
      if (!doodleDrawing) return
      const rect = doodleCanvas.getBoundingClientRect()
      const cx = e.clientX - rect.left
      const cy = e.clientY - rect.top
      const p = canvasToImage(cx, cy)
      const cur = doodleStrokes[doodleStrokes.length - 1]
      if (cur) cur.push(p)
      drawDoodle()
    })
    window.addEventListener('mouseup', (e) => {
      if (!doodleDrawing) return
      doodleDrawing = false
    })

    // Toggle via button
    btnDoodle.addEventListener('click', () => {
      if (!selected) return
      doodleMode = !doodleMode
      btnDoodle.textContent = doodleMode ? '‚ùå Exit Doodle' : '‚úèÔ∏è Doodle'
      doodleCanvas.style.display = doodleMode ? 'block' : 'none'
      if (doodleMode) {
        resizeDoodleCanvas()
        drawDoodle()
        // enable undo if there are doodle strokes
        try { btnUndo.disabled = doodleStrokes.length === 0 } catch(e){}
      } else {
        clearDoodle()
        // when exiting doodle mode, restore undo to annotation history
        try { btnUndo.disabled = history.length === 0 } catch(e){}
      }
    })

    // Escape clears doodle and exits doodle mode (but does not affect saved annotations)
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && doodleMode) {
        doodleMode = false
        doodleCanvas.style.display = 'none'
        clearDoodle()
        btnDoodle.textContent = '‚úèÔ∏è Doodle'
      }
    })

    
    // Close measurement popup on click
    const closeMeasurementPopup = () => {
      measurementPopup.style.display = 'none'
      measurementBackdrop.style.display = 'none'
    }
    
    measurementPopup.addEventListener('click', (e) => {
      e.stopPropagation()
      closeMeasurementPopup()
    })
    
    measurementBackdrop.addEventListener('click', (e) => {
      e.stopPropagation()
      closeMeasurementPopup()
    })
    
    // Also close on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && measurementPopup.style.display === 'block') {
        closeMeasurementPopup()
      }
    })
    
    confirmBoundaryModal.addEventListener('click', (e) => {
      if (e.target === confirmBoundaryModal) {
        currentPoints = []
        pendingBoundary = null
        pendingBoundaryStep = 0
        confirmBoundaryModal.style.display = 'none'
        updateWip()
        drawAll()
      }
    })
    
    // ---------- Boundary confirmation modal ----------
    btnConfirmBoundary.addEventListener('click', () => {
      if (!pendingBoundary) return
      
      if (pendingBoundaryStep === 1) {
        topBoundary = pendingBoundary
        currentPoints = []
        trajectoryStep = 2
        trajectoryStepEl.textContent = 'Step 2: Draw the BOTTOM boundary of the tube (click multiple points, finish at end)'
        updateTrajectoryButtonState()
      } else if (pendingBoundaryStep === 2) {
        bottomBoundary = pendingBoundary
        currentPoints = []
        trajectoryStep = 3
        
        tubeCenterline = computeCenterline(topBoundary, bottomBoundary)
        
        if (tubeCenterline) {
          recomputeTrajectoryDistances()
          updateTrajectoryButtonState()
          persistTrajectory()
          persist()
          setDirty(true)
          renderTable()
        } else {
          alert('Failed to compute centerline. Please try redrawing the boundaries.')
          trajectoryStep = 1
          topBoundary = null
          bottomBoundary = null
          updateTrajectoryButtonState()
          trajectoryStepEl.textContent = 'Step 1: Draw the TOP boundary of the tube (click multiple points, finish at end)'
        }
      }
      
      pendingBoundary = null
      pendingBoundaryStep = 0
      confirmBoundaryModal.style.display = 'none'
      drawAll()
    })
    
    btnCancelBoundary.addEventListener('click', () => {
      currentPoints = []
      pendingBoundary = null
      pendingBoundaryStep = 0
      confirmBoundaryModal.style.display = 'none'
      updateWip()
      drawAll()
    })

    window.addEventListener('beforeunload', (e) => {
      if (dirty) {
        e.preventDefault()
        e.returnValue = ''
      }
    })

    window.addEventListener('keydown', (e) => { 
      if (e.key === 'a' || e.key === 'A') holdingA = true 
      if (e.key === 'u' || e.key === 'U') {
        magnifierEnabled = !magnifierEnabled
        magnifierCanvas.style.display = magnifierEnabled ? 'block' : 'none'
        if (!magnifierEnabled) {
          magnifierCanvas.style.display = 'none'
        }
      }
    })
    window.addEventListener('keyup', (e) => { if (e.key === 'a' || e.key === 'A') holdingA = false })

    // ---------- ZIP handling ----------
    zipInput.addEventListener('change', (e) => {
      zipFile = e.target.files && e.target.files[0]
      btnUseZip.disabled = !zipFile
      if (zipFile) datasetId = zipFile.name.replace(/\W+/g, '_')
    })

    const releaseBlobUrls = () => {
      images.forEach(img => {
        if (img.objectUrl) {
          URL.revokeObjectURL(img.objectUrl)
        }
      })
    }

    btnUseZip.addEventListener('click', async () => {
      if (!zipFile) return
      btnUseZip.disabled = true
      releaseBlobUrls()
      images = []
      selected = null
      titleEl.textContent = 'Indexing ZIP‚Ä¶'
      imageListEl.innerHTML = ''
      imgEl.src = ''
      try {
        const zip = await JSZip.loadAsync(zipFile)
        const files = Object.values(zip.files)
        const metaTexts = {}
        for (const f of files) {
          if (f.dir) continue
          const lname = f.name.toLowerCase()
          if (lname.endsWith('.xml')) {
            metaTexts[lname] = await zip.file(f.name).async('text')
          }
        }
        const extractExposure = (imgName) => {
          const base = imgName.replace(/^.*\//, '')
          const variants = [
            `data/metadata/${base}.cal.xml`,
            `data/metadata/${base}.tif.cal.xml`,
            `metadata/${base}.cal.xml`,
            `metadata/${base}.tif.cal.xml`,
            `${base}.cal.xml`,
          ]
          const m = base.lastIndexOf('.')
          const noext = m>=0? base.slice(0,m): base
          variants.push(
            `data/metadata/${noext}.tif.cal.xml`,
            `data/metadata/${noext}.cal.xml`,
            `metadata/${noext}.tif.cal.xml`,
            `metadata/${noext}.cal.xml`,
            `${noext}.cal.xml`
          )
          for (const v of variants) {
            const t = metaTexts[v.toLowerCase()]
            if (t) {
              const m1 = t.match(/<Exposure>([^<]+)<\/Exposure>/i)
              if (m1) {
                const n = (m1[1].match(/([0-9]*\.?[0-9]+)/) || [])[1]
                if (n) return Number(n)
              }
            }
          }
          for (const [k, t] of Object.entries(metaTexts)) {
            if (k.includes(noext.toLowerCase())) {
              const m1 = t.match(/<Exposure>([^<]+)<\/Exposure>/i)
              if (m1) {
                const n = (m1[1].match(/([0-9]*\.?[0-9]+)/) || [])[1]
                if (n) return Number(n)
              }
            }
          }
          return null
        }

        for (const f of files) {
          if (f.dir) continue
          const lname = f.name.toLowerCase()
          const basename = f.name.replace(/^.*\//, '')
          if (basename.startsWith('._')) continue
          if (!(lname.endsWith('.tif') || lname.endsWith('.tiff') || lname.endsWith('.png') || lname.endsWith('.jpg') || lname.endsWith('.jpeg'))) continue
          let url = ''
          let objectUrl = null
          if (lname.endsWith('.tif') || lname.endsWith('.tiff')) {
            const buf = await zip.file(f.name).async('arraybuffer')
            const ifds = UTIF.decode(buf)
            if (ifds && ifds.length) {
              UTIF.decodeImage(buf, ifds[0])
              const rgba = UTIF.toRGBA8(ifds[0])
              const width = Math.max(1, Math.floor(Number(ifds[0].width || ifds[0].ImageWidth || ifds[0].cols || 0)))
              const height = Math.max(1, Math.floor(Number(ifds[0].height || ifds[0].ImageLength || ifds[0].rows || 0)))
              if (width > 0 && height > 0) {
                const c = document.createElement('canvas')
                c.width = width
                c.height = height
                const cctx = c.getContext('2d')
                const imgData = cctx.createImageData(width, height)
                imgData.data.set(rgba)
                cctx.putImageData(imgData, 0, 0)
                url = c.toDataURL('image/png')
              }
            }
          } else {
            const blob = await zip.file(f.name).async('blob')
            objectUrl = URL.createObjectURL(blob)
            url = objectUrl
          }
          if (!url) continue
          const exposureMs = extractExposure(f.name)
          images.push({ name: f.name.replace(/^.*\//,''), url, exposureMs, thumbUrl: url, objectUrl })
        }

        if (!images.length) {
          titleEl.textContent = 'No images found in ZIP'
          return
        }
        titleEl.textContent = 'Select an image'
        renderImageList()
      } catch (err) {
        console.error('ZIP error', err)
        titleEl.textContent = 'Failed to read ZIP'
      } finally {
        btnUseZip.disabled = false
      }
    })

    function renderImageList() {
      imageListEl.innerHTML = ''
      images.forEach((img) => {
        const li = document.createElement('li')
        li.addEventListener('click', () => selectImage(img))
        li.className = selected && selected.name === img.name ? 'active' : ''
        const thumb = document.createElement('img')
        thumb.src = img.thumbUrl
        thumb.className = 'thumb'
        const meta = document.createElement('div')
        meta.className = 'meta'
        const nameDiv = document.createElement('div')
        nameDiv.className = 'name'
        nameDiv.textContent = img.name
        const subDiv = document.createElement('div')
        subDiv.className = 'sub'
        subDiv.textContent = img.exposureMs != null ? `Exposure: ${img.exposureMs} ms` : ''
        meta.appendChild(nameDiv); meta.appendChild(subDiv)
        li.appendChild(thumb); li.appendChild(meta)
        imageListEl.appendChild(li)
      })
    }

    function selectImage(img) {
      selected = img
      titleEl.textContent = img.name
      expLabel.textContent = img.exposureMs != null ? String(img.exposureMs) : 'N/A'
      imgEl.src = img.url
      imgEl.onload = () => { resizeCanvas(); try { resizeDoodleCanvas() } catch(e){}; drawAll(); try { drawDoodle() } catch(e){} }
      currentPoints = []
      loadAnnotationsFor(img.name)
      btnClear.disabled = annotations.length === 0
      btnSaveCsv.disabled = false
      btnTrajectory.disabled = false
      btnMeasure.disabled = false
  btnDoodle.disabled = false
      updateWip()
      renderImageList()
    }

    function updateWip(){
      if (measureMode) {
        wipStatus.style.display = 'none'
        if (measurePoints.length > 0) {
          let distPx = 0
          for(let i = 0; i < measurePoints.length - 1; i++){
            const dx = measurePoints[i+1].x - measurePoints[i].x
            const dy = measurePoints[i+1].y - measurePoints[i].y
            distPx += Math.hypot(dx, dy)
          }
          const distUm = pxToMicron(distPx)
          measureStatus.textContent = ` üìè Measuring: ${Math.round(distUm * 1000) / 1000} ¬µm (${measurePoints.length} point${measurePoints.length > 1 ? 's' : ''}, click to add more or finish)`
          measureStatus.style.display = 'inline'
        } else {
          measureStatus.style.display = 'none'
        }
      } else {
        measureStatus.style.display = 'none'
        wipStatus.style.display = 'inline'
        wipStatus.textContent = currentPoints.length ? ` (${currentPoints.length} point${currentPoints.length>1?'s':''} added, click to finish or hold A to add more)` : ''
      }
    }

    function resizeCanvas() {
      if (!imgEl.naturalWidth) return
      const DPR = dpr()
      const displayW = imgEl.clientWidth
      const displayH = imgEl.clientHeight
      canvas.width = Math.max(1, Math.floor((displayW - pad*2) * DPR))
      canvas.height = Math.max(1, Math.floor((displayH - pad*2) * DPR))
      canvas.style.width = `${displayW - pad*2}px`
      canvas.style.height = `${displayH - pad*2}px`
      canvas.style.left = pad + 'px'
      canvas.style.top = pad + 'px'
      // Keep doodle canvas in sync
      try { resizeDoodleCanvas() } catch(e){}
    }

    window.addEventListener('resize', () => { resizeCanvas(); drawAll(); try { drawDoodle() } catch(e){} })

    function drawAll() {
      if (!imgEl.naturalWidth) return
      const DPR = dpr()
      ctx.setTransform(DPR,0,0,DPR,0,0)
      const displayW = imgEl.clientWidth - pad*2
      const displayH = imgEl.clientHeight - pad*2
      ctx.clearRect(0,0,displayW,displayH)
      ctx.lineWidth = 2

      const toDisp = (p) => imageToCanvas(p.x, p.y)

      // Draw tube boundaries and centerline if trajectory mode is active
      if (topBoundary && topBoundary.length > 0) {
        const pts = topBoundary.map(toDisp)
        ctx.strokeStyle = '#ff6b6b'
        ctx.lineWidth = 2
        ctx.beginPath()
        ctx.moveTo(pts[0].x, pts[0].y)
        for (let i = 1; i < pts.length; i++) {
          ctx.lineTo(pts[i].x, pts[i].y)
        }
        ctx.stroke()
      }
      
      if (bottomBoundary && bottomBoundary.length > 0) {
        const pts = bottomBoundary.map(toDisp)
        ctx.strokeStyle = '#ff6b6b'
        ctx.lineWidth = 2
        ctx.beginPath()
        ctx.moveTo(pts[0].x, pts[0].y)
        for (let i = 1; i < pts.length; i++) {
          ctx.lineTo(pts[i].x, pts[i].y)
        }
        ctx.stroke()
      }
      
      if (tubeCenterline && tubeCenterline.length > 0) {
        const pts = tubeCenterline.map(toDisp)
        ctx.strokeStyle = '#4caf50'
        ctx.lineWidth = 3
        ctx.setLineDash([8, 4])
        ctx.beginPath()
        ctx.moveTo(pts[0].x, pts[0].y)
        for (let i = 1; i < pts.length; i++) {
          ctx.lineTo(pts[i].x, pts[i].y)
        }
        ctx.stroke()
        ctx.setLineDash([])
      }

      ctx.lineWidth = 2

      // Draw completed annotations
      annotations.forEach((a, idx) => {
        if (!a.points || a.points.length<2) return
        const pts = a.points.map(toDisp)
        const isHovered = idx === hoveredAnnotationIndex
        
        if (isHovered) {
          ctx.strokeStyle = '#ffeb3b'
          ctx.lineWidth = 4
          ctx.shadowBlur = 10
          ctx.shadowColor = 'rgba(255,235,59,0.8)'
        } else {
          ctx.strokeStyle = '#36a3ff'
          ctx.lineWidth = 2
          ctx.shadowBlur = 0
        }
        
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y)
        for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y) }
        ctx.stroke()
        
        ctx.shadowBlur = 0
        
        pts.forEach((dp, ptIdx)=>{
          ctx.beginPath();
          if (isHovered) {
            ctx.fillStyle = ptIdx===0? '#ffeb3b' : (ptIdx===pts.length-1? '#ff9800':'#ffc107')
            ctx.arc(dp.x, dp.y, 7, 0, Math.PI*2)
          } else {
            ctx.fillStyle = ptIdx===0? '#2fb8ff' : (ptIdx===pts.length-1? '#ff7b7b':'#ffeb3b')
            ctx.arc(dp.x, dp.y, 5, 0, Math.PI*2)
          }
          ctx.fill()
        })
      })

      // Draw WIP line
      if (currentPoints.length>0) {
        const pts = currentPoints.map(toDisp)
        ctx.setLineDash([5,5])
        ctx.strokeStyle = trajectoryMode && trajectoryStep < 3 ? '#ff6b6b' : '#36a3ff'
        ctx.lineWidth = trajectoryMode && trajectoryStep < 3 ? 3 : 2
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y)
        for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y) }
        ctx.stroke(); ctx.setLineDash([])
        pts.forEach((dp, idx)=>{
          ctx.beginPath(); ctx.fillStyle = idx===0? '#2fb8ff':'#ffeb3b'
          ctx.arc(dp.x, dp.y, 5, 0, Math.PI*2); ctx.fill()
        })
      }
      
      // Draw measurement line
      if (measureMode && measurePoints.length > 0) {
        const pts = measurePoints.map(toDisp)
        ctx.setLineDash([5,5])
        ctx.strokeStyle = '#ff9800'
        ctx.lineWidth = 3
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y)
        for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y) }
        ctx.stroke(); ctx.setLineDash([])
        pts.forEach((dp, idx)=>{
          ctx.beginPath(); ctx.fillStyle = '#ff9800'
          ctx.arc(dp.x, dp.y, 6, 0, Math.PI*2); ctx.fill()
        })
      }
    }

    function annotationToRow(a, idx){
      const pts = a.points || []
      const start = pts[0] || {x:0,y:0}
      const end = pts[pts.length-1] || {x:0,y:0}
      const showDistFromCenter = trajectoryMode && trajectoryStep === 3
      const tr = document.createElement('tr')
      tr.dataset.annotationIndex = idx
      tr.innerHTML = `
        <td><button class="btn-delete" data-del="${idx}" title="Delete annotation">üóëÔ∏è</button></td>
        <td>${idx+1}</td>
        <td>${pts.length}</td>
        <td>${Math.round(start.x)},${Math.round(start.y)}</td>
        <td>${Math.round(end.x)},${Math.round(end.y)}</td>
        <td>${Math.round(a.distUm*1000)/1000}</td>
        <td>${a.distError != null ? Math.round(a.distError*1000)/1000 : ''}</td>
        <td>${a.exposureMs ?? ''}</td>
        <td>${a.timeError != null ? Math.round(a.timeError*1000)/1000 : ''}</td>
        <td>${a.velUmS? Math.round(a.velUmS*1000)/1000 : ''}</td>
        <td>${a.velError != null ? Math.round(a.velError*1000)/1000 : ''}</td>
        <td style="display:${showDistFromCenter ? 'table-cell' : 'none'}">${a.distFromCenter != null ? Math.round(a.distFromCenter*1000)/1000 : ''}</td>`
      
      tr.addEventListener('mouseenter', () => {
        hoveredAnnotationIndex = idx
        drawAll()
      })
      
      tr.addEventListener('mouseleave', () => {
        hoveredAnnotationIndex = -1
        drawAll()
      })
      
      return tr
    }

    function renderTable(){
      tableBody.innerHTML = ''
      annotations.forEach((a, i)=> tableBody.appendChild(annotationToRow(a,i)))
      const showDistFromCenter = trajectoryMode && trajectoryStep === 3
      thDistFromCenter.style.display = showDistFromCenter ? 'table-cell' : 'none'
    }

    tableBody.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-del]')
      if (!btn) return
      const idx = Number(btn.getAttribute('data-del'))
      pushHistory()
      annotations = annotations.filter((_,j)=> j!==idx)
      persist(); setDirty(true)
      btnClear.disabled = annotations.length===0
      renderTable(); drawAll()
    })

    // ---------- Measure button ----------
    btnMeasure.addEventListener('click', () => {
      if (!selected) return
      
      if (measureMode) {
        // Disable measure mode
        measureMode = false
        measurePoints = []
        btnMeasure.textContent = 'üìè Measure Length'
        btnMeasure.style.background = 'linear-gradient(180deg,#ff9800,#f57c00)'
        updateWip()
        drawAll()
      } else {
        // Enable measure mode
        measureMode = true
        measurePoints = []
        btnMeasure.textContent = '‚ùå Cancel Measure'
        btnMeasure.style.background = 'linear-gradient(180deg,#f44336,#d32f2f)'
        updateWip()
      }
    })
    
    // ---------- Trajectory buttons ----------
    btnTrajectory.addEventListener('click', () => {
      if (!selected) return
      
      if (trajectoryMode) {
        if (!confirm('Disable trajectory analysis? This will clear the tube boundaries.')) return
        resetTrajectoryState()
        currentPoints = []
        
        annotations.forEach(a => delete a.distFromCenter)
        
        persistTrajectory()
        persist()
        setDirty(true)
        renderTable()
        drawAll()
      } else {
        trajectoryMode = true
        trajectoryStep = 1
        topBoundary = null
        bottomBoundary = null
        tubeCenterline = null
        currentPoints = []
        updateTrajectoryButtonState()
        trajectoryStepEl.textContent = 'Step 1: Draw the TOP boundary of the tube (click multiple points, finish at end)'
        drawAll()
      }
    })
    
    btnClearBoundaries.addEventListener('click', () => {
      if (!selected || !trajectoryMode) return
      if (!confirm('Clear tube boundaries and restart? This will remove distance-from-center data.')) return
      
      trajectoryStep = 1
      topBoundary = null
      bottomBoundary = null
      tubeCenterline = null
      currentPoints = []
      
      annotations.forEach(a => delete a.distFromCenter)
      
      updateTrajectoryButtonState()
      trajectoryStepEl.textContent = 'Step 1: Draw the TOP boundary of the tube (click multiple points, finish at end)'
      
      persistTrajectory()
      persist()
      setDirty(true)
      renderTable()
      drawAll()
    })

    // ---------- Canvas interactions ----------
    
    function isPointNearLine(point, linePoints, threshold = 10) {
      if (!linePoints || linePoints.length < 2) return false
      
      for (let i = 0; i < linePoints.length - 1; i++) {
        const p1 = linePoints[i]
        const p2 = linePoints[i + 1]
        
        const dx = p2.x - p1.x
        const dy = p2.y - p1.y
        const len2 = dx * dx + dy * dy
        
        if (len2 === 0) {
          const dist = Math.hypot(point.x - p1.x, point.y - p1.y)
          if (dist <= threshold) return true
        } else {
          let t = ((point.x - p1.x) * dx + (point.y - p1.y) * dy) / len2
          t = Math.max(0, Math.min(1, t))
          const projX = p1.x + t * dx
          const projY = p1.y + t * dy
          const dist = Math.hypot(point.x - projX, point.y - projY)
          if (dist <= threshold) return true
        }
      }
      return false
    }
    
    canvas.addEventListener('mousemove', (e) => {
      if (!selected || !imgEl.naturalWidth) {
        crosshair.classList.remove('active')
        magnifierCanvas.style.display = 'none'
        return
      }
      
      const rect = canvas.getBoundingClientRect()
      const canvasX = e.clientX - rect.left
      const canvasY = e.clientY - rect.top
      
      // Position crosshair in page coordinates relative to imageWrap
      const wrapRect = imageWrap.getBoundingClientRect()
      crosshair.style.left = `${e.clientX - wrapRect.left}px`
      crosshair.style.top = `${e.clientY - wrapRect.top}px`
      crosshair.classList.add('active')
      
      // Handle magnifier
      if (magnifierEnabled) {
        const magnifierSize = 150
        const zoomFactor = 3
        magnifierCanvas.width = magnifierSize
        magnifierCanvas.height = magnifierSize
        magnifierCanvas.style.width = magnifierSize + 'px'
        magnifierCanvas.style.height = magnifierSize + 'px'
        
        // Position magnifier offset from cursor
        const offsetX = 20
        const offsetY = 20
        magnifierCanvas.style.left = `${e.clientX - wrapRect.left + offsetX}px`
        magnifierCanvas.style.top = `${e.clientY - wrapRect.top + offsetY}px`
        magnifierCanvas.style.display = 'block'
        
        // Draw magnified section
        const imagePoint = canvasToImage(canvasX, canvasY)
        const srcSize = magnifierSize / zoomFactor
        const srcX = Math.max(0, Math.min(imgEl.naturalWidth - srcSize, imagePoint.x - srcSize / 2))
        const srcY = Math.max(0, Math.min(imgEl.naturalHeight - srcSize, imagePoint.y - srcSize / 2))
        
        magnifierCtx.clearRect(0, 0, magnifierSize, magnifierSize)
        magnifierCtx.drawImage(imgEl, srcX, srcY, srcSize, srcSize, 0, 0, magnifierSize, magnifierSize)
        
        // Draw crosshair in magnifier center
        magnifierCtx.strokeStyle = '#36a3ff'
        magnifierCtx.lineWidth = 2
        magnifierCtx.beginPath()
        magnifierCtx.moveTo(magnifierSize / 2, 0)
        magnifierCtx.lineTo(magnifierSize / 2, magnifierSize)
        magnifierCtx.moveTo(0, magnifierSize / 2)
        magnifierCtx.lineTo(magnifierSize, magnifierSize / 2)
        magnifierCtx.stroke()
      } else {
        magnifierCanvas.style.display = 'none'
      }
      
      if (annotations.length === 0) return
      
      const imagePoint = canvasToImage(canvasX, canvasY)
      
      let newHoveredIndex = -1
      const threshold = 15
      
      for (let i = 0; i < annotations.length; i++) {
        if (isPointNearLine(imagePoint, annotations[i].points, threshold)) {
          newHoveredIndex = i
          break
        }
      }
      
      if (newHoveredIndex !== hoveredAnnotationIndex) {
        hoveredAnnotationIndex = newHoveredIndex
        
        const rows = tableBody.querySelectorAll('tr')
        rows.forEach((row, idx) => {
          if (idx === hoveredAnnotationIndex) {
            row.classList.add('highlight')
          } else {
            row.classList.remove('highlight')
          }
        })
        
        drawAll()
      }
    })
    
    canvas.addEventListener('mouseleave', () => {
      crosshair.classList.remove('active')
      magnifierCanvas.style.display = 'none'
      if (hoveredAnnotationIndex !== -1) {
        hoveredAnnotationIndex = -1
        const rows = tableBody.querySelectorAll('tr')
        rows.forEach(row => row.classList.remove('highlight'))
        drawAll()
      }
    })
    
    canvas.addEventListener('click', (e)=>{
      if (!selected || !imgEl.naturalWidth) return
      
      const rect = canvas.getBoundingClientRect()
      const canvasX = e.clientX - rect.left
      const canvasY = e.clientY - rect.top
      
      // Convert to image coordinates
      const point = canvasToImage(canvasX, canvasY)
      
      // Clamp to image bounds to handle edge cases properly
      point.x = Math.max(0, Math.min(imgEl.naturalWidth, point.x))
      point.y = Math.max(0, Math.min(imgEl.naturalHeight, point.y))
      
      console.log('[v0] Click:', { canvas: {x: canvasX, y: canvasY}, image: point })

      // Handle measure mode
      if (measureMode) {
        if (measurePoints.length === 0) {
          measurePoints = [point]
        } else if (holdingA) {
          measurePoints = [...measurePoints, point]
        } else {
          // Finish measurement - calculate and show popup
          const all = [...measurePoints, point]
          let distPx = 0
          for(let i = 0; i < all.length - 1; i++){
            const dx = all[i+1].x - all[i].x
            const dy = all[i+1].y - all[i].y
            distPx += Math.hypot(dx, dy)
          }
          const distUm = pxToMicron(distPx)
          
          // Show popup with result
          measurementValue.textContent = (Math.round(distUm * 1000) / 1000).toFixed(3)
          measurementBackdrop.style.display = 'block'
          measurementPopup.style.display = 'block'
          
          // Reset measurement
          measurePoints = []
        }
        updateWip()
        drawAll()
        return
      }

      // Handle trajectory mode boundary drawing
      if (trajectoryMode && trajectoryStep < 3) {
        if (currentPoints.length === 0) {
          currentPoints = [point]
        } else if (holdingA) {
          currentPoints = [...currentPoints, point]
        } else {
          const all = [...currentPoints, point]
          pendingBoundary = all
          pendingBoundaryStep = trajectoryStep
          
          if (trajectoryStep === 1) {
            confirmBoundaryTitle.textContent = 'Confirm TOP Boundary'
            confirmBoundaryMessage.textContent = 'Is this TOP boundary line correct?'
          } else if (trajectoryStep === 2) {
            confirmBoundaryTitle.textContent = 'Confirm BOTTOM Boundary'
            confirmBoundaryMessage.textContent = 'Is this BOTTOM boundary line correct?'
          }
          
          confirmBoundaryModal.style.display = 'flex'
        }
        updateWip()
        drawAll()
        return
      }

      // Normal annotation mode
      if (currentPoints.length===0) {
        currentPoints = [point]
      } else if (holdingA) {
        currentPoints = [...currentPoints, point]
      } else {
        pushHistory()
        const all = [...currentPoints, point]
        let distPx = 0
        for(let i=0;i<all.length-1;i++){
          const dx = all[i+1].x - all[i].x
          const dy = all[i+1].y - all[i].y
          distPx += Math.hypot(dx,dy)
        }
        const distUm = pxToMicron(distPx)
        
        // Calculate errors
        const pixelError = 0.5 // error in pixels
        const distError = pxToMicron(pixelError / 2) // distance error in ¬µm
        
        const exp = selected.exposureMs ?? null
        const timeError = exp ? Number(inpTimeError.value) : null // time error in ms
        
        const velUmMs = exp? (distUm/exp): null
        const velUmS = velUmMs? velUmMs*1000 : null
        
        // Error propagation for velocity: sqrt((distError/dist)^2 + (timeError/time)^2) * velocity
        let velError = null
        if (velUmS && distUm && exp && distError && timeError) {
          const relDistError = distError / distUm
          const relTimeError = timeError / exp
          const relVelError = Math.sqrt(relDistError * relDistError + relTimeError * relTimeError)
          velError = relVelError * velUmS
        }
        
        let distFromCenter = null
        if (trajectoryMode && trajectoryStep === 3 && tubeCenterline) {
          const centroid = computeLineCentroid(all)
          if (centroid) {
            const distPxFromCenter = distanceFromCenterline(centroid, tubeCenterline)
            distFromCenter = distPxFromCenter !== null ? pxToMicron(distPxFromCenter) : null
          }
        }
        
        const newAnnotation = {
          points: all, 
          distPx, 
          distUm,
          distError,
          exposureMs: exp,
          timeError,
          velUmMs, 
          velUmS,
          velError
        }
        
        if (distFromCenter !== null) {
          newAnnotation.distFromCenter = distFromCenter
        }
        
        annotations = [...annotations, newAnnotation]
        currentPoints = []
        persist(); setDirty(true)
        btnClear.disabled = annotations.length===0
        renderTable()
      }
      updateWip(); drawAll()
    })

    // ---------- Controls ----------
    btnUndo.addEventListener('click', ()=>{
      // If in doodle mode, undo the last doodle stroke
      if (doodleMode) {
        if (!doodleStrokes || doodleStrokes.length === 0) return
        doodleStrokes.pop()
        drawDoodle()
        btnUndo.disabled = doodleStrokes.length === 0
        return
      }

      // Otherwise, undo the last annotation change
      if (history.length===0) return
      annotations = history.pop()
      btnUndo.disabled = history.length===0
      persist(); setDirty(true)
      btnClear.disabled = annotations.length===0
      renderTable(); drawAll()
    })

    btnClear.addEventListener('click', ()=>{
      if (!selected || annotations.length===0) return
      if (!confirm('Clear all annotations for this image?')) return
      pushHistory()
      annotations = []
      persist(); setDirty(true)
      btnClear.disabled = true
      renderTable(); drawAll()
    })

    btnSaveCsv.addEventListener('click', ()=>{
      if (!selected) return
      const showDistFromCenter = trajectoryMode && trajectoryStep === 3
      const header = showDistFromCenter 
        ? ['points','num_points','dist_um','dist_error_um','exposure_ms','time_error_ms','vel_um_s','vel_error_um_s','dist_from_center_um']
        : ['points','num_points','dist_um','dist_error_um','exposure_ms','time_error_ms','vel_um_s','vel_error_um_s']
      
      const rows = annotations.map(a=>{
        const pts = a.points || []
        const ptsStr = pts.map(p=>`${Math.round(p.x)},${Math.round(p.y)}`).join(';')
        const baseRow = [
          ptsStr,
          pts.length,
          Math.round(a.distUm*1000)/1000,
          a.distError != null ? Math.round(a.distError*1000)/1000 : '',
          a.exposureMs ?? '',
          a.timeError != null ? Math.round(a.timeError*1000)/1000 : '',
          a.velUmS? Math.round(a.velUmS*1000)/1000 : '',
          a.velError != null ? Math.round(a.velError*1000)/1000 : ''
        ]
        
        if (showDistFromCenter) {
          baseRow.push(a.distFromCenter != null ? Math.round(a.distFromCenter*1000)/1000 : '')
        }
        
        return baseRow.join(',')
      })
      const csv = [header.join(','), ...rows].join('\n')
      const blob = new Blob([csv], {type:'text/csv'})
      const a = document.createElement('a')
      a.href = URL.createObjectURL(blob)
      a.download = `${selected.name}.annotations.csv`
      a.click()
      setDirty(false)
    })

    csvInput.addEventListener('change', ()=>{
      const f = csvInput.files && csvInput.files[0]
      if (!f) return
      const reader = new FileReader()
      reader.onload = ()=>{
        const txt = String(reader.result || '')
        const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean)
        if (lines.length<2) return
        const header = lines[0].split(',').map(h => h.trim().toLowerCase())
        const colIndex = (name) => header.indexOf(name)
        const idxPoints = colIndex('points')
        const idxDistPx = colIndex('dist_px')
        const idxDistUm = colIndex('dist_um')
        const idxExposure = colIndex('exposure_ms')
        const idxVelUmS = colIndex('vel_um_s')
        const idxVelUmMs = colIndex('vel_um_ms')
        const idxDistFromCenter = colIndex('dist_from_center_um')
        
        pushHistory()
        const rows = lines.slice(1)
        const arr = []
        rows.forEach(r=>{
          const cols = r.split(',').map(c=>c.trim())
          const pointsCell = idxPoints >= 0 ? cols[idxPoints] : cols[0]
          if (!pointsCell) return
          const pts = pointsCell.split(';').map(pair=>{
            const [x,y] = pair.split(',').map(n=>Number(n))
            return {x, y}
          }).filter(p=>!isNaN(p.x)&&!isNaN(p.y))
          if (pts.length<2) return
          let distPx = 0
          for(let i=0;i<pts.length-1;i++){
            const dx = pts[i+1].x - pts[i].x
            const dy = pts[i+1].y - pts[i].y
            distPx += Math.hypot(dx,dy)
          }
          const distPxCol = idxDistPx >= 0 && cols[idxDistPx] ? Number(cols[idxDistPx]) : distPx
          const distUm = idxDistUm >= 0 && cols[idxDistUm] ? Number(cols[idxDistUm]) : pxToMicron(distPxCol)
          const exp = idxExposure >= 0 && cols[idxExposure] ? Number(cols[idxExposure]) : (selected?.exposureMs ?? null)
          const velUmMs = idxVelUmMs >= 0 && cols[idxVelUmMs] ? Number(cols[idxVelUmMs]) : (exp ? (distUm/exp) : null)
          const velUmS = idxVelUmS >= 0 && cols[idxVelUmS] ? Number(cols[idxVelUmS]) : (velUmMs ? velUmMs * 1000 : null)
          
          const annotation = {points: pts, distPx: distPxCol, distUm, exposureMs: exp, velUmMs, velUmS}
          
          if (idxDistFromCenter >= 0 && cols[idxDistFromCenter]) {
            annotation.distFromCenter = Number(cols[idxDistFromCenter])
          }
          
          arr.push(annotation)
        })
        annotations = arr
        persist(); setDirty(true)
        btnClear.disabled = annotations.length===0
        renderTable(); drawAll()
      }
      reader.readAsText(f)
    })

    inpScalePx.addEventListener('change', ()=> drawAll())
    inpScaleUm.addEventListener('change', ()=> drawAll())

  })()
  </script>
</body>
</html>
 